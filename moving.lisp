(in-package #:org.shirakumo.fraf.leaf)

(define-subject moving (game-entity)
  ((surface :initform NIL :accessor surface)
   (collisions :initform (make-array 4) :reader collisions)))

(defmethod enter :after ((moving moving) (chunk chunk))
  (setf (surface moving) chunk))

(defmethod leave :after ((moving moving) (chunk chunk))
  (setf (surface moving) NIL))

(defmethod scan (entity target))

(defmethod tick ((moving moving) ev)
  (let* ((surface (surface moving))
         (loc (location moving))
         (vel (velocity moving))
         (size (bsize moving)))
    ;; Scan for hits until we run out of velocity or hits.
    (fill (collisions moving) NIL)
    (loop while (and (or (/= 0 (vx vel)) (/= 0 (vy vel)))
                     (scan surface moving)))
    ;; Remaining velocity (if any) can be added safely.
    (nv+ loc vel)
    ;; Point test for adjacent walls
    (let ((tl (scan surface (vec (- (vx loc) (vx size) 1) (+ (vy loc) (vy size) -1))))
          (bl (scan surface (vec (- (vx loc) (vx size) 1) (- (vy loc) (vy size) -1))))
          (tr (scan surface (vec (+ (vx loc) (vx size) 1) (+ (vy loc) (vy size) -1))))
          (br (scan surface (vec (+ (vx loc) (vx size) 1) (- (vy loc) (vy size) -1))))
          (b  (scan surface (vec (vx loc) (- (vy loc) (vy size) 1)))))
      (when (or tl bl) (setf (aref (collisions moving) 3) (or tl bl)))
      (when (or tr br) (setf (aref (collisions moving) 1) (or tr br)))
      (when b (setf (aref (collisions moving) 2) b)))
    ;; Point test for interactables. Pretty stupid.
    (for:for ((entity over surface))
      (when (and (not (eq entity moving))
                 (typep entity 'interactable)
                 (contained-p entity loc))
        (collide moving entity (make-hit entity 0.0 loc (vec 0 0)))))))

(defmethod collide ((moving moving) (block ground) hit)
  (let* ((loc (location moving))
         (vel (velocity moving))
         (pos (hit-location hit))
         (normal (hit-normal hit))
         (height (vy (bsize moving)))
         (t-s (/ (block-s block) 2)))
    (cond ((= +1 (vy normal)) (setf (svref (collisions moving) 2) block))
          ((= -1 (vy normal)) (setf (svref (collisions moving) 0) block))
          ((= +1 (vx normal)) (setf (svref (collisions moving) 3) block))
          ((= -1 (vx normal)) (setf (svref (collisions moving) 1) block)))
    (nv+ loc (v* vel (hit-time hit)))
    (nv- vel (v* normal (v. vel normal)))
    ;; Zip out of ground in case of clipping
    (cond ((and (/= 0 (vy normal))
                 (< (vy pos) (vy loc))
                 (< (- (vy loc) height)
                    (+ (vy pos) t-s)))
           (setf (vy loc) (+ (vy pos) t-s height)))
          ((and (/= 0 (vy normal))
                (< (vy loc) (vy pos))
                (< (- (vy pos) t-s)
                   (+ (vy loc) height)))
           (setf (vy loc) (- (vy pos) t-s height))))))

(defmethod collides-p ((moving moving) (block platform) hit)
  (< (vy (velocity moving)) 0))

(defmethod collide ((moving moving) (block platform) hit)
  (let* ((loc (location moving))
         (vel (velocity moving))
         (pos (hit-location hit))
         (normal (hit-normal hit))
         (height (vy (bsize moving)))
         (t-s (/ (block-s block) 2)))
    (setf (svref (collisions moving) 2) block)
    (nv+ loc (v* vel (hit-time hit)))
    (nv- vel (v* normal (v. vel normal)))
    ;; Zip
    (when (< (- (vy loc) height)
             (+ (vy pos) t-s))
      (setf (vy loc) (+ (vy pos) t-s height)))))

(defmethod collide ((moving moving) (block spike) hit)
  (die moving))

(defmethod collides-p ((moving moving) (block slope) hit)
  (and (if (< (slope-l block) (slope-r block))
           (<= 0 (vx (velocity moving)))
           (< (vx (velocity moving)) 0))
       (<= (+ (vy (location moving))
              (vy (velocity moving)))
           (+ (vy (hit-location hit))
              (- (/ +tile-size+ 2))
              (max (slope-l block) (slope-r block))))))

(defmethod collide ((moving moving) (block slope) hit)
  (let* ((loc (location moving))
         (vel (velocity moving))
         (pos (hit-location hit))
         (height (vy (bsize moving)))
         (t-s (/ (block-s block) 2))
         (l (slope-l block))
         (r (slope-r block)))
    ;; FIXME: slopes lol
    ))
