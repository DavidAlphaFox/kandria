(in-package #:org.shirakumo.fraf.leaf)

(define-action movement ())

(define-action dash (movement)
  (key-press (one-of key :left-shift))
  (gamepad-press (one-of button :x)))

(define-action start-jump (movement)
  (key-press (one-of key :space))
  (gamepad-press (one-of button :a)))

(define-action start-left (movement)
  (key-press (one-of key :a :left))
  (gamepad-move (one-of axis :l-h :dpad-h) (< pos -0.2 old-pos)))

(define-action start-right (movement)
  (key-press (one-of key :d :e :right))
  (gamepad-move (one-of axis :l-h :dpad-h) (< old-pos 0.2 pos)))

(define-action start-up (movement)
  (key-press (one-of key :w :\, :up))
  (gamepad-move (one-of axis :l-v :dpad-v) (< pos -0.2 old-pos)))

(define-action start-down (movement)
  (key-press (one-of key :s :o :down))
  (gamepad-move (one-of axis :l-v :dpad-v) (< old-pos 0.2 pos)))

(define-action end-jump (movement)
  (key-release (one-of key :space))
  (gamepad-release (one-of button :a)))

(define-action end-left (movement)
  (key-release (one-of key :a :left))
  (gamepad-move (one-of axis :l-h :dpad-h) (< old-pos -0.2 pos)))

(define-action end-right (movement)
  (key-release (one-of key :d :e :right))
  (gamepad-move (one-of axis :l-h :dpad-h) (< pos 0.2 old-pos)))

(define-action end-up (movement)
  (key-release (one-of key :w :\, :up))
  (gamepad-move (one-of axis :l-v :dpad-v) (< old-pos -0.2 pos)))

(define-action end-down (movement)
  (key-release (one-of key :s :o :down))
  (gamepad-move (one-of axis :l-v :dpad-v) (< pos 0.2 old-pos)))

(define-retention movement (ev)
  (typecase ev
    (start-jump (setf (retained 'movement :jump) T))
    (start-left (setf (retained 'movement :left) T))
    (start-right (setf (retained 'movement :right) T))
    (start-up (setf (retained 'movement :up) T))
    (start-down (setf (retained 'movement :down) T))
    (end-jump (setf (retained 'movement :jump) NIL))
    (end-left (setf (retained 'movement :left) NIL))
    (end-right (setf (retained 'movement :right) NIL))
    (end-up (setf (retained 'movement :up) NIL))
    (end-down (setf (retained 'movement :down) NIL))))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defclass located-entity (entity)
    ((location :initarg :location :initform (vec 0 0) :accessor location))))

(defmethod paint :around ((obj located-entity) target)
  (with-pushed-matrix ()
    (translate (vxy_ (location obj)))
    (call-next-method)))

(define-subject moving (located-entity)
  ((velocity :initarg :velocity :accessor velocity)
   (size :initarg :size :accessor size))
  (:default-initargs :velocity (vec 0 0)
                     :size (vec *default-tile-size* *default-tile-size*)))

(define-generic-handler (moving tick trial:tick))

(defmethod scan (entity size start dir))

(defun closer (a b dir)
  (< (abs (v. a dir)) (abs (v. b dir))))

(defmethod tick ((moving moving) ev)
  (let ((scene (scene (handler *context*)))
        (loc (location moving))
        (vel (velocity moving))
        (size (size moving)))
    ;; Scan for hits until we run out of velocity or hits.
    (catch 'a
      (loop while (or (/= 0 (vx vel)) (/= 0 (vy vel)))
            for hit = (scan scene size loc vel)
            while hit
            do (collide moving (hit-object hit) hit)))
    ;; Remaining velocity (if any) can be added safely.
    (nv+ loc vel)
    (vsetf loc (round (vx loc)) (round (vy loc)))))

(defmethod collide ((moving moving) (block block) hit)
  (let* ((loc (location moving))
         (vel (velocity moving))
         (pos (hit-location hit))
         (normal (hit-normal hit))
         (height (/ (vy (size moving)) 2))
         (t-s (/ (block-s block) 2))
         (l (block-l block))
         (r (block-r block)))
    (cond ((= 0 l r)
           (nv+ loc (v* vel (hit-time hit)))
           (nv- vel (v* normal (v. vel normal)))
           ;; Zip out of ground in case of clipping
           (when (and (/= 0 (vy normal))
                      (< (vy pos) (vy loc))
                      (< (- (vy loc) height)
                         (+ (vy pos) t-s)))
             (setf (vy loc) (+ (vy pos) t-s height))))
          (T
           (nv+ loc vel)
           (let* ((tt (max 0 (min 1 (/ (- (vx loc) (- (vx pos) t-s)) (* 2 t-s)))))
                  (sy (+ (- (vy pos) t-s) height l (* (- r l) tt))))
             (when (< (vy loc) sy)
               (setf (vy loc) sy)
               (setf (vy vel) 0)))
           (throw 'a NIL)))))

(define-shader-subject player (vertex-entity colored-entity moving)
  ((vlim :initform (vec 10 10) :accessor vlim)
   (vacc :initform (vec 1 2) :accessor vacc)
   (vdcc :initform (vec 5 10) :accessor vdcc)
   (jmp-count :initform 0 :accessor jmp-count)
   (dash-count :initform 0 :accessor dash-count))
  (:default-initargs
   :vertex-array (asset 'leaf 'player)
   :location (vec 32 32)
   :size (vec 8 16)
   :name :player))

(define-handler (player dash) (ev)
  (let ((vel (velocity player))
        (dacc 5))
    (when (= 0 (dash-count player))
      (vsetf vel
             (cond ((retained 'movement :left)  -1)
                   ((retained 'movement :right) +1)
                   (T                            0))
             (cond ((retained 'movement :up)    +1)
                   ((retained 'movement :down)  -1)
                   (T                            0)))
      (when (v= 0 vel)
        (setf (vx vel) 1))
      (nv* vel (/ dacc (vlength vel)))
      (incf (dash-count player) 0.001))))

(defmethod collide :after ((player player) (block block) hit)
  (when (/= 0 (vy (hit-normal hit)))
    (setf (jmp-count player) 0)
    (when (< 20 (dash-count player))
      (setf (dash-count player) 0))))

(defmethod tick :before ((player player) ev)
  (let ((vel (velocity player))
        (dt (coerce (dt ev) 'single-float))
        (vlim (vec2 10 10))
        (vacc (vec2 1 2))
        (vdcc (vec2 5 10)))
    (setf (vx (color player)) 0)
    (setf (vy (color player)) (if (= 0 (dash-count player)) 1 0))
    (cond ((< 0 (dash-count player) 20)
           (incf (dash-count player))
           (nv* vel 0.95)
           (setf (vx (color player)) 1))
          (T
           (cond ((retained 'movement :left)
                  (setf (vx vel) (- (vx vacc))))
                 ((retained 'movement :right)
                  (setf (vx vel) (vx vacc)))
                 (T
                  (setf (vx vel) 0)))
           (when (or (< 0 (jmp-count player))
                     (retained 'movement :jump))
             (cond ((= 0 (jmp-count player))
                    (setf (vy vel) (vy vacc)))
                   ((and (retained 'movement :jump)
                         (= 15 (jmp-count player)))
                    (setf (vy vel) (* 3.5 (vy vel)))))
             (incf (jmp-count player)))
           (decf (vy vel) (* dt (vy vdcc)))
           (nvclamp (v- vlim) vel vlim))))
  ;; OOB
  (when (< (vy (location player)) 0)
    (setf (vy (location player)) 128)
    (setf (vy (velocity player)) 0)))
