(in-package #:org.shirakumo.fraf.leaf)

(define-shader-entity enemy (animatable)
  ((bsize :initform (vec 12.0 8.0))
   (cooldown :initform 0.0 :accessor cooldown))
  (:default-initargs
   :sprite-data (asset 'leaf 'wolf)))

(defmethod capable-p ((enemy enemy) (edge jump-edge)) T)

(defmethod handle :before ((ev tick) (enemy enemy))
  (when (path enemy)
    (return-from handle))
  (let ((collisions (collisions enemy))
        (acc (acceleration enemy))
        (dt (* 100 (dt ev))))
    (setf (vx acc) (* (vx acc) (damp* (vy +vmove+) dt)))
    (nv+ acc (v* +vgrav+ dt))
    (cond ((svref collisions 2)
           (when (<= -0.1 (vx acc) 0.1)
             (setf (vx acc) 0)))
          (T
           (when (<= 2 (vx acc))
             (setf (vx acc) (* (vx acc) (damp* 0.90 dt))))))
    (when (svref collisions 0) (setf (vy acc) (min 0 (vy acc))))
    (when (svref collisions 1) (setf (vx acc) (min 0 (vx acc))))
    (when (svref collisions 3) (setf (vx acc) (max 0 (vx acc))))
    (case (state enemy)
      ((:dying :animated :stunned)
       (handle-animation-states enemy ev))
      (T
       (handle-ai-states enemy ev)))
    (nvclamp (v- +vlim+) acc +vlim+)
    (nv+ (velocity enemy) acc)))

(defmethod handle :after ((ev tick) (enemy enemy))
  ;; Animations
  (let ((acc (acceleration enemy))
        (collisions (collisions enemy)))
    (case (state enemy)
      ((:dying :animated :stunned))
      (T
       (cond ((< 0 (vx acc))
              (setf (direction enemy) +1))
             ((< (vx acc) 0)
              (setf (direction enemy) -1)))
       (cond ((< 0 (vy acc))
              (setf (animation enemy) 'jump))
             ((null (svref collisions 2))
              (setf (animation enemy) 'fall))
             ((< 0 (abs (vx acc)) 1.0)
              (setf (animation enemy) 'walk))
             ((<= 1.0 (abs (vx acc)))
              (setf (animation enemy) 'run))
             (T
              (setf (animation enemy) 'stand)))))))

(define-shader-entity wolf (enemy)
  ())

(defmethod handle-ai-states ((enemy wolf) ev)
  (let* ((player (unit 'player T))
         (ploc (location player))
         (eloc (location enemy))
         (distance (vlength (v- ploc eloc)))
         (col (collisions enemy))
         (acc (acceleration enemy)))
    (ecase (state enemy)
      (:normal
       (if (< distance 400)
           (setf (state enemy) :approach)
           (ignore-errors (move-to (vec (+ (vx (location enemy)) (- (random 100) 50)) (vy (location enemy))) enemy))))
      (:approach
       ;; FIXME: This should be reached even when there is a path being executed right now.
       (cond ((< distance 200)
              (setf (path enemy) ())
              (setf (state enemy) :attack))
             ((null (path enemy))
              (ignore-errors (move-to (location player) enemy)))))
      (:evade
       (if (< 100 distance)
           (setf (state enemy) :attack)
           (let ((dir (signum (- (vx eloc) (vx ploc)))))
             (when (and (svref col 2) (svref col (if (< 0 dir) 1 3)))
               (setf (vy acc) 3.2))
             (setf (vx acc) (* dir 2.0)))))
      (:attack
       (cond ((< 500 distance)
              (setf (state enemy) :normal))
             ((< distance 80)
              (setf (state enemy) :evade))
             (T
              (setf (direction enemy) (signum (- (vx (location player)) (vx (location enemy)))))
              (cond ((svref col (if (< 0 (direction enemy)) 1 3))
                     (setf (vy acc) 2.0)
                     (setf (vx acc) (* (direction enemy) 2.0)))
                    ((svref col 2)
                     (setf (vy acc) 0.0)
                     ;; Check that tackle would even be possible to hit (no obstacles)
                     (start-animation 'tackle enemy)))))))))
