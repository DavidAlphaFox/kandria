<article><style>article{
    max-width: 800px;
    font-size: 12pt;
    font-family: sans-serif;
    margin: 3em auto;
}

article h1{
    text-align: center;
    font-size: 2em;
}

article img{
    margin: 0 auto;
    max-width: 100%;
}

article blockquote{
    border-left: 0.2em solid gray;
    margin-left: 1em;
    padding-left: 1em;
}

article figcaption{
    padding: 0.2em 1em;
    background: #E0E0E0;
}

article code{
    background: #F0F0F0;
    padding: 0 0.1em;
}

article .code-block{
    padding: 0.1em 0.5em;
}</style><h1 id="lisp crash course">Lisp Crash Course</h1><p>This document is a very brief and short introduction course to Common Lisp, the programming language used for Kandria and many of its other systems. You are not expected to become a programmer or write code beyond some simple lines, so don't worry. Still, Lisp is different from other languages is a couple of ways, so try to go into this with a clear head and don't try to relate it to other languages you might already be familiar with.</p><p>If any questions come up, don't hesitate to contact Shinmera and ask for help. Seriously, do <em>not</em> hesitate.</p><h2 id="basic syntax">Basic Syntax</h2><p>Lisp syntax consists of a few basic constructs:</p><ul><li><p>Numbers</p><ul><li><p>Integers<br>Integers are just that: digits. <code>0</code>, <code>-1</code>, <code>69</code>.</p></li><li><p>Ratios<br>Ratios are less frequently used: <code>1/2</code>, <code>4/9</code>, <code>4/2</code>.</p></li><li><p>Floats<br>Floating point numbers involve a decimal point: <code>0.0</code>, <code>-1.0</code>, <code>+1.5</code>.</p></li></ul></li><li><p>Strings<br>Strings are sequences of characters: <code>&quot;string&quot;</code>, <code>&quot;a string with a quote: \&quot;wow\&quot;.&quot;</code></p></li><li><p>Symbols<br>Symbols are names used to name functions, variables, and other things like entities: <code>player</code>, <code>insert</code>, <code>+</code>, <code>T</code>, <code>NIL</code>.<br>See the <a class="cross-reference" href="#symbols">symbols section</a> for more information on symbol usage and precise syntax.</p></li><li><p>Lists<br>Lists are a type of sequence often used in Lisp: <code>(1 2 3)</code>, <code>()</code>, <code>(a &quot;b&quot; 2.0)</code>.<br>They can contain any other type of object. Notable is that the empty list <code>()</code> is the same as the symbol <code>NIL</code> and may be used interchangeably. By convention however you should use <code>NIL</code> to denote &quot;nothing&quot; and <code>()</code> to denote an empty list.</p></li><li><p>Vectors<br>Vectors are another type of sequence: <code>#(1 2 3)</code>, <code>#()</code>, <code>#(a &quot;b&quot; 2.0)</code>.<br>Just like lists they can contain any other type of object and are often used in contexts where speed is important. You'll probably see these less often.</p></li></ul><p>In addition to the syntax for these basic objects, Lisp notation includes a few shorthand constructs to make things easier to type. Most of these are indicated by the hash-sign prefixing them.</p><ul><li><p><code>#b1010</code><br>Allows writing an integer in binary notation.</p></li><li><p><code>#xBEEF</code><br>Allows writing an integer in hexadecimal notation.</p></li><li><p><code>#&lt;THING&gt;</code><br>This is syntax for an &quot;unreadable object&quot; meaning it's only there when shown back to you by a program and cannot occur in source text.</p></li><li><p><code>#'foo</code><br>This is shorthand to designate a function, in this case one called <code>FOO</code>. See <a class="cross-reference" href="#function objects">function objects</a>.</p></li><li><p><code>#:foo</code><br>An <a class="cross-reference" href="#uninterned symbols">uninterned symbol</a>, in this case named <code>FOO</code>. Don't worry about what exactly that means for now, just know it's another type of symbol.</p></li><li><p><code>#'foo</code></p></li><li><p><code>'foo</code><br>The quote character is used to <a class="cross-reference" href="#quotation">quote an expression</a>. Following the quote can be any other object, not just a symbol like here.</p></li></ul><p>There's more syntax constructs in Lisp, but they are less frequently used and aren't too important.</p><h2 id="evaluation">Evaluation</h2><p>Code isn't actually code unless it is <em>evaluated</em> or executed. The following terms are important to explain how Lisp code is executed, so we'll lay them out first:</p><ul><li><p>Source Code<br>Code as written by you into a text file.</p></li><li><p>Literal<br>A literal is any kind of object that you write in source code. Stuff like a number or a string you wrote, but also the source code itself and things that are <a class="cross-reference" href="#quotation">quoted</a></p></li><li><p>Expression<br>An expression is some object denoted in source code.</p></li><li><p>Form<br>An expression that will be evaluated.</p></li><li><p>Value<br>Any object that is used when code is evaluated.</p></li><li><p>Dynamic / dynamically<br>Performed when code is evaluated. The opposite of</p></li><li><p>Static / statically<br>Known ahead of time as it is literally in the source code.</p></li></ul><p>Now, Lisp follows a fairly simple execution model, which we will discuss by looking at a couple of examples. If you've set up the development environment from the <a class="external-link" href="getting started.html">getting started guide</a>, you can also try these out yourself by typing them into the prompt. When entering something into the REPL as it is called, the source code is parsed (or <em>read</em>), compiled, and evaluated. The result of evaluating your code is then <em>printed</em> back to you at the REPL.</p><code style="display:block" class="code-block" data-language="common lisp"><pre>&quot;Hello World&quot;</pre></code><p>This is the most mundane and boring program you could write. It's the classic &quot;Hello World&quot; example, where a program just prints back <code>Hello World</code> at you. In Lisp with the REPL, the string is first read into a string object, which is then evaluated. Strings, like most objects, &quot;evaluate to themselves&quot;. This means that the string is just returned as the result of the evaluation. Thus, you get the string back on the REPL. </p><p>You can do the same experiment with numbers and vectors, but not with lists or symbols. When evaluated as a <em>form</em>, lists and symbols carry special meaning.</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(+ 1 2)</pre></code><p>This program adds one and two together, and returns three.</p><p>Note how the list is used to express a function call. When this program is evaluated, Lisp sees a list and thus knows a function call is about to happen. It then looks at the first item in the list, which must be a symbol. In this case it's the symbol <code>+</code>, which denotes the addition function. It then looks at the remaining elements of the list and evaluates them in turn. Since both remaining list elements are numbers, they evaluate to themselves, thus we get <code>1</code> and <code>2</code> as the <em>arguments</em> to the function. The function <code>+</code> is then <em>invoked</em> with these arguments. The <em>return value</em> of this invocation is then returned as the result of the program.</p><p>The evaluation process is inherently <em>recursive</em>, as each argument to a function is <em>evaluated</em>. We can see this more clearly by looking at the following:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(/ (+ 2 3 4) 3)</pre></code><p>This program computes the average of the numbers two, three, and four, which is three.</p><p>We make use of a new function here, <code>/</code>, which is the division operator. It divides the first argument by all remaining arguments. We also make use of <code>+</code>' ability to take an arbitrary number of arguments. Note the recursive nature of evaluation: first Lisp sees a list, looks at the <code>/</code> to find the function, then evaluates <code>(+ 2 3 4)</code>. It sees another list, look sat the <code>+</code> to find the function, then evaluates <code>2</code>, <code>3</code>, and <code>4</code>, calls <code>+</code> with the numbers as arguments, and uses the return value of <code>9</code> as the first argument to <code>/</code>. It then evaluates <code>3</code> and calls <code>/</code> with <code>9</code> and <code>3</code>, finding the final return value of <code>3</code>.</p><p>To summarise: in Lisp function calls are denoted by lists, where the first element in the list is the function name, and all remaining elements of the list are recursively evaluated to obtain the arguments to the function call.</p><p>We'll now quickly look at variables and bindings. As you might have noticed, symbols also play a special role in evaluation, but not only to denote function names, but also to denote <em>variables</em>. Let's look at the following example:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>PI</pre></code><p>This is another very simple program. When read, this is turned into the symbol <code>PI</code>. When a symbol is evaluated outside of the context of a function call, it is treated as a variable and whatever value is <em>bound</em> to the symbol is returned. In this case, the value of Pi is returned as a floating point number.</p><p>We can establish new variables with the special construct <code>let</code>. <code>let</code> allows us to introduce new variables for a limited part of the program (a <em>scope</em>). Unlike other functions, <code>let</code> is a <em>special operator</em> and thus can establish special semantic rules. Let's have a look at an example:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(let ((brother-age 25)
      (sister-age 27))
  (/ (+ brother-age sister-age) 2))</pre></code><p>This program computes the average age of the two siblings, which is <code>26</code>.</p><p>When Lisp sees a <code>let</code> call, it stops its normal evaluation rules and instead follows special rules. Namely, the second element of the list must be a list of <em>variable bindings</em>. Each element of this variable binding list must be another list that has two elements: a symbol naming the variable, and a value to bind to the new variable.</p><p>Thus in the above program we establish two new variable bindings, one called <code>brother-age</code>, and one called <code>sister-age</code>. These variable bindings are only active within the <code>let</code> call. After the variable bindings, <code>let</code> expects any number of other forms as its <em>body</em>. These forms now have access to the new variable bindings.</p><p>From here evaluation proceeds very similar to before, just instead of the numbers being arguments to <code>+</code> directly, we instead evaluate the symbols <code>brother-age</code> and <code>sister-age</code>, which will return <code>25</code> and <code>27</code> respectively, as that's what they were bound to.</p><p><code>let</code> ultimately returns whatever the return value was of the last form in its body, in this case <code>26</code>.</p><p>An example of an <em>invalid program</em> would be the following:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(let ((brother-age 25)
      (sister-age 27))
  (/ (+ brother-age sister-age) 2))
brother-age</pre></code><a id="errors"></a><p>In this case <code>brother-age</code> is <em>referenced</em> outside of the <code>let</code> that binds it. In the scope outside the <code>let</code>, Lisp does not know of any variable named <code>brother-age</code> and thus generates an error. When an <em>unhandled error</em> is <em>signalled</em> in Lisp, it will automatically open up a debugger. This allows you to look at the source of the error and try to fix it. Most times you'll simply want to abort the evaluation, so simply click on the lowest <code>ABORT</code> button, or press <code>a</code> within the debugger.</p><p>Let's keep the ante up and look at a more involved program:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(let ((ages (list 18 32 25 27 43)))
  (/ (reduce #'+ ages) (length ages)))</pre></code><p>This program computes the average of the ages <code>18</code>, <code>32</code>, <code>25</code>, <code>27</code>, and <code>43</code>, which happens to be <code>29</code>.</p><p>Unlike previously though we <em>dynamically</em> compute the average. You can add or remove ages from the <code>ages</code> list and it'll keep computing the average no matter the length. To do this we use the function <code>list</code>, which simply constructs a list object from its arguments. We then bind this list to the <code>ages</code> variable with <code>let</code>. Then we sum up all of the elements of the list using <code>reduce</code>.</p><a id="function objects"></a><p>Here we see the first use of the <code>#'FOO</code> syntax. This syntax is the same as <code>(FUNCTION FOO)</code>. <code>function</code> is another special operator like <code>let</code>, which when encountered returns the <em>function object</em> named by its argument. In this case it returns the function <code>+</code> so that we can use it as a value for <code>reduce</code>.</p><p><code>reduce</code> is a function that takes another function and a list of elements as arguments. It then successively applies this other function to the elements of the list to &quot;reduce&quot; it to one value. In the above example it first evaluates <code>(+ 18 32)</code>, yielding <code>50</code>. It then evaluates <code>(+ 50 25)</code>, yielding <code>75</code>. It then evaluates <code>(+ 75 27)</code>, yielding <code>102</code>. Finally it evaluates <code>(+ 102 43)</code>, yielding <code>145</code>.</p><p>We then also evaluate <code>(length ages)</code>. <code>length</code> is a function that returns how many elements a sequence has, in this case <code>5</code>.</p><p>Thus we get to our final <code>(/ 145 5)</code>, yielding the return value of <code>29</code>.</p><a id="function definition"></a><p>The point of dynamic evaluation here might not be too poignant when written as a single program like this. However, we can factor out the body of our <code>let</code> into a function that can compute the average of any list it is given, instead. Defining new functions is done through another special operator called <code>defun</code>:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(defun average (ages)
  (/ (reduce #'+ ages) (length ages)))</pre></code><p><code>defun</code> first expects the name of the function to define, then a list that describes the arguments the function should expect, followed by a body of forms to evaluate when the function is invoked. Similar to <code>let</code>, the value returned by the last form in the body is used as the return value of the function.</p><p>Now that we have the averaging as a function, we can recreate our previous program like this:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(average (list 18 32 25 27 43))</pre></code><p>At this point you may also have been confused by the difference between <code>(list 1 2 3)</code> and <code>(1 2 3)</code>. If the latter is already a list anyway, what's the point of the <code>list</code> function? Can't we just write <code>(1 2 3)</code>?</p><p>The easiest answer is that normally Lisp expects the first item of a list to be a function name. <code>1</code> is not a function name, therefore <code>(1 2 3)</code> is not a valid Lisp form. We use the function <code>list</code> to construct a list dynamically and use the resulting list value instead.</p><a id="quotation"></a><p>However, there's another method to get a list as a value, which is through quotation. Quotation takes an expression you wrote in source code and turns it into a <em>literal object</em>, preventing it from being evaluated. Using quotation we can rewrite the previous program like this:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(average '(18 32 25 27 43))</pre></code><p>The <code>'(18 32 25 27 43)</code> is short for <code>(QUOTE (18 32 25 27 43))</code>. <code>quote</code> is another special operator which, when evaluated, simply returns its argument as a literal value without evaluating it. Quotation is also often used to use symbols as names for things. By quoting the symbol it won't be treated as a variable, instead returning the symbol itself so that it can be used as a name. For example: </p><code style="display:block" class="code-block" data-language="common lisp"><pre>(position 'name '(hello there my name is noodle))</pre></code><p>This program returns the index of the symbol <code>NAME</code> within the list <code>(HELLO THERE MY NAME IS NOODLE)</code>, which is <code>3</code>.</p><p>Using symbols and lists we can also create association maps (dictionaries, or tables, whatever term you like best) by using lists composed out of a key and a value:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>'((name &quot;The Stranger&quot;)
  (age NIL)
  (location (100 2010))
  (health 90))</pre></code><p>This is called an &quot;association list&quot;, or &quot;alist&quot; for short. We can retrieve the value associated with the key like this:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(second (assoc 'name '((name &quot;The Stranger&quot;)
                       (age NIL)
                       (location (100 2010))
                       (health 90))))</pre></code><p>This program returns &quot;The Stranger&quot;. The <code>assoc</code> function searches for a list that begins with the first arguments it is given in the elements of its second argument. In this case it returns <code>(name &quot;The stranger&quot;)</code>. The <code>second</code> function then returns the second element of that list, <code>&quot;The Stranger&quot;</code>.</p><p>Another common form of map is the &quot;property list&quot;, or &quot;plist&quot;. Instead of using a list for each entry in the map, keys and values are interleaved instead. The same map could thus be expressed as a plist like this:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(name &quot;The Stranger&quot;
 age NIL
 location (100 2010)
 health 90)</pre></code><p>Rewriting the above program to use a plist, we get:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(getf '(name &quot;The Stranger&quot;
        age NIL
        location (100 2010)
        health 90)
      'name)</pre></code><p>Often plists are written with <a class="cross-reference" href="#symbols">keywords</a> for the keys instead of regular symbols.</p><p>In general, the fact that lists, symbols, and other objects are so easy to access and create in Lisp source code makes it very tempting to use Lisp source, or in the very least its syntax, for data storage. Several of Kandria's data files make use of Lisp syntax to store data and code. Lisp being highly flexible and dynamic also makes it an ideal candidate as a scripting language itself, which is why whenever script-like things are needed in Kandria, Lisp code is used directly instead of creating or using a third-party language.</p><p>This concludes the most important aspects of evaluation in Lisp. To summarise again:</p><ul><li><p>Normally the first element of a list must be a symbol denoting the name of a function to call, and the other elements in the list designate the arguments to call the function with.</p></li><li><p>Arguments to a function are themselves evaluated recursively.</p></li><li><p>Normally a lone symbol designates a variable. Evaluating a variable yields the value it is bound to.</p></li><li><p>Any object that is not a list or a symbol evaluates to itself.</p></li><li><p>Special operators like <code>let</code>, <code>function</code>, <code>defun</code>, and <code>quote</code> can change the semantics of evaluation.</p></li><li><p>Variable bindings can be established using <code>let</code>.</p></li><li><p>In order to prevent the evaluation of an expression and instead use it as data, quotation can be used.</p></li></ul><p>This completes the most important aspects of Lisp programming. Following are a few additional pieces of information that will be useful to know when dealing with code and data in Kandria.</p><h2 id="places">Places</h2><p>Another concept you'll encounter frequently in Lisp code is that of <em>places</em>. A place is something that can be read and written to in code. There's many different kinds of places that can be used, but the simplest is a variable. In order to modify any place, the <code>setf</code> special operator is used.</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(let ((name &quot;The Stranger&quot;))
  (setf name &quot;Fi&quot;)
  name)</pre></code><p>This program returns &quot;Fi&quot;, as the variable binding for <code>name</code> was modified with <code>setf</code> so that it was now bound to <code>&quot;Fi&quot;</code> rather than its original binding value of <code>&quot;The Stranger&quot;</code>.</p><p>Another example of a place is the function <code>nth</code> that accesses the nth element of a list:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(let ((numbers (list 1 2 3 4 5)))
  (setf (nth 1 numbers) (nth 2 numbers))
  numbers)</pre></code><p>A lot of things in Lisp can be modified as a place, and you can also add new places. For the purposes of this crash course, just remember that you can change stuff using <code>setf</code>.</p><h2 id="symbols">Symbols</h2><p>So far the symbols we've encountered have all been in &quot;short form&quot;. Symbol syntax is actually quite a bit more involved, and each symbol also carries more properties than just its name. The only thing we'll look at here in relation to symbols is packages.</p><a id="uninterned symbols"></a><p>A symbol is a name that may be <em>interned</em> in a <em>package</em>. Symbols that are not interned in any package are called &quot;uninterned symbols&quot; and are written using the <code>#:FOO</code> syntax. Typically however, symbols are interned and are thus home to one or more packages. In order to reference a symbol from a specific package, you can use the extended syntax of <code>package-name:symbol-name</code>.</p><p>So far we had always used symbols without the package qualifier, in which case they are interned in the <em>current package</em>. The current package can be controlled and is often either explicitly set by the system, or declared at the beginning of a source file using <code>in-package</code>.</p><p>Whenever an unqualified symbol is read, Lisp checks whether a symbol of the requested name already exists in the current package. If it does, the existing symbol object is used. If not, a new symbol object of that name is created and interned into the current package.</p><p>For qualified symbols the behaviour is slightly different – if the symbol does not exist or is not <em>exported</em>, an error is signalled instead. In order for a symbol that is interned in a package to be accessible outside of it, it must thus be explicitly exported. This ensures that one cannot accidentally use symbols that were not meant to be used.</p><a id="keywords"></a><p>Symbols that are home to the package named <code>KEYWORD</code> can also be written by omitting the package name from the extended syntax, meaning <code>:symbol-name</code>. Keywords are quite frequently used to denote named arguments and other properties or attributes, as they are easy to access from any package. Any symbol interned in the keyword package is also automatically turned into a variable that holds the keyword itself as the value.</p><h2 id="more">More</h2><p>This crash course only covers the bare essentials in very little depth. If you are interested enough to see a much more detailed and extensive coverage of Lisp's capabilities, please see the excellent <a class="external-link" href="http://www.gigamonkeys.com/book/">Practical Common Lisp</a>, available for free online.</p></article>