(in-package #:org.shirakumo.fraf.kandria)

(defun compute-frame-location (animation frames frame-idx)
  (let ((location (vec 0 0))
        (frame (svref frames frame-idx)))
    (loop for i from (start animation) below frame-idx
          for frame = (svref frames i)
          for vel = (velocity frame)
          for offset = (v* vel (duration frame) 100)
          do (nv+ location offset))
    (nv+ location (v* (velocity frame)
                      (duration frame)
                      100 0.5))
    location))

(defmethod update-hurtbox ((sprite animatable) start end)
  (let* ((hurtbox (hurtbox (frame animatable)))
         (bsize (nvabs (nv/ (v- end start) 2)))
         (loc (nv- (v+ start bsize) (compute-frame-location (animation animatable) (frames animatable) (frame-idx animatable)))))
    (setf (vx hurtbox) (vx loc))
    (setf (vy hurtbox) (vy loc))
    (setf (vz hurtbox) (vx bsize))
    (setf (vw hurtbox) (vy bsize))))

(defclass animation-editor (tool)
  ((start-pos :initform NIL :accessor start-pos)
   (timeline :initform NIL :accessor timeline)))

(defmethod initialize-instance :after ((editor animation-editor) &key)
  (make-instance 'timeline :ui (unit 'ui-pass T)))

(define-handler (animation-editor mouse-press) (pos button)
  (when (eql button :middle)
    (setf (start-pos animation-editor) (to-world-pos pos))
    (update-hurtbox animation-editor (to-world-pos pos) (to-world-pos pos))))

(define-handler (animation-editor mouse-release) (pos button)
  (when (eql button :middle)
    (update-hurtbox animation-editor (start-pos animation-editor) (to-world-pos pos))
    (setf (start-pos animation-editor) NIL)))

(define-handler (animation-editor mouse-move) (pos)
  (when (start-pos animation-editor)
    (update-hurtbox animation-editor (start-pos editor-sprite) (to-world-pos pos))))

(defmethod update-hurtbox ((tool animation-editor) start end)
  (update-hurtbox (entity tool) start end))

(defmethod handle ((event key-release) (tool animation-editor))
  ;; FIXME: refresh frame representation in editor on change
  (let ((entity (entity editor))
        (frame (frame entity)))
    (case (key event)
      (:space
       (if (= (playback-speed entity) 0f0)
           (setf (playback-speed entity) 1f0)
           (setf (playback-speed entity) 0f0)))
      (:delete
       (clear frame))
      ((:a :n :left)
       (decf (frame-idx entity))
       (when (retained :shift)
         (transfer-frame (frame entity) frame)))
      ((:d :p :right)
       (incf (frame-idx entity))
       (when (retained :shift)
         (transfer-frame (frame entity) frame))))))

(defmethod applicable-tools append ((_ animatable))
  '(animation-editor))

(defclass timeline (alloy:window alloy:observable-object)
  ((animation :accessor animation)
   (entity :initarg :entity :accessor entity))
  (:default-initargs :title "Animations"
                     :extent (alloy:extent 0 0 (alloy:vw 100) 300)
                     :minimizable T
                     :maximizable NIL))

(defmethod initialize-instance :after ((timeline timeline) &key entity)
  (let ((layout (make-instance 'org.shirakumo.alloy.layouts.constraint:layout :layout-parent timeline))
        (focus (make-instance 'alloy:focus-list :focus-parent timeline))
        (animations (mapcar #'name (animations entity)))
        (animation (alloy:represent (slot-value editor 'animation) 'alloy:combo-set :value-set animations))
        (frames (make-instance 'alloy:horizontal-linear-layout :cell-margins (alloy:margins) :min-size (alloy:size 100 300)))
        (scroll (make-instance 'alloy:scroll-view :scroll-x :focus focus :layout frames)))
    (alloy:enter scroll layout :constraints '((:left 100) (:bottom 0) (:right 0) (:top 30)))
    (alloy:enter animation layout :constraints '((:left 0) (:top 0) (:width 100) (:height 30)))
    (alloy:on animation (animation timeline)
      (setf (animation entity) animation)
      (populate-frames frames focus entity animation))
    (setf (animation timeline) (animation entity))))

(defun populate-frames (layout focus entity animation)
  (alloy:clear layout)
  (alloy:clear focus)
  (loop for i from (start animation) below (end animation)
        for frame = (aref (frames entity) i)
        do (make-instance 'frame-edit :idx i :frame frame :layout-parent layout :focus-parent focus)))

(alloy:define-widget frame-edit (alloy:structure)
  ((frame-idx :initarg :idx :representation (alloy:button) :reader frame-idx)
   (frame :initarg :frame :reader frame)))

(defmethod initialize-instance :after ((edit frame-edit) &key)
  (alloy:finish-structure edit (slot-value edit 'layout) (slot-value edit 'focus)))

(alloy:define-subcomponent (frame-edit hurtbox) ((hurtbox (frame frame-edit)) trial-alloy::vec4))
(alloy:define-subcomponent (frame-edit velocity) ((velocity (frame frame-edit)) trial-alloy::vec2))
(alloy:define-subcomponent (frame-edit multiplier) ((multiplier (frame frame-edit)) trial-alloy::vec2))
(alloy:define-subcomponent (frame-edit knockback) ((knockback (frame frame-edit)) trial-alloy::vec2))
(alloy:define-subcomponent (frame-edit damage) ((damage (frame frame-edit)) alloy:wheel))
(alloy:define-subcomponent (frame-edit stun) ((stun-time (frame frame-edit)) alloy:wheel))
(alloy:define-subcomponent (frame-edit interruptable) ((interruptable-p (frame frame-edit)) alloy:checkbox))
(alloy:define-subcomponent (frame-edit invincible) ((invincible-p (frame frame-edit)) alloy:checkbox))
(alloy:define-subcomponent (frame-edit cancelable) ((cancelable-p (frame frame-edit)) alloy:checkbox))
(alloy:define-subcomponent (frame-edit effect) ((effect (frame frame-edit)) alloy:combo-set :value-set '(NIL)))

(alloy:define-subcontainer (frame-edit layout)
    (alloy:vertical-linear-layout :cell-margins (alloy:margins 1))
  frame-idx hurtbox velocity multiplier knockback damage stun interruptable invincible cancelable effect)

(alloy:define-subcontainer (frame-edit focus)
    (alloy:focus-list)
  frame-idx hurtbox velocity multiplier knockback damage stun interruptable invincible cancelable effect)
