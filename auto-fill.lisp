(in-package #:org.shirakumo.fraf.leaf)

(defun %flood-fill (layer width height x y fill)
  (let* ((tmp (vec2 0 0)))
    (labels ((pos (x y)
               (* (+ x (* y width)) 2))
             (tile (x y)
               (vsetf tmp
                      (aref layer (+ 0 (pos x y)))
                      (aref layer (+ 1 (pos x y)))))
             ((setf tile) (f x y)
               (setf (aref layer (+ 0 (pos x y))) (truncate (vx f))
                     (aref layer (+ 1 (pos x y))) (truncate (vy f)))))
      (let ((q ()) (find (vec2 (aref layer (+ 0 (pos x y)))
                               (aref layer (+ 1 (pos x y))))))
        (unless (v= fill find)
          (push (cons x y) q)
          (loop while q for (n . y) = (pop q)
                for w = n for e = n
                do (loop until (or (= w 0) (v/= (tile (1- w) y) find))
                         do (decf w))
                   (loop until (or (= e (1- width)) (v/= (tile (1+ e) y) find))
                         do (incf e))
                   (loop for i from w to e
                         do (setf (tile i y) fill)
                            (when (and (< y (1- height)) (v= (tile i (1+ y)) find))
                              (pushnew (cons i (1+ y)) q))
                            (when (and (< 0 y) (v= (tile i (1- y)) find))
                              (pushnew (cons i (1- y)) q)))))))))

(defun find-edge (solids width height x y)
  (labels ((pos (x y)
             (* (+ x (* y width)) 2)))
    (loop with state = :up
          while (= 255 (aref solids (+ 0 (pos x y))))
          do (ecase state
               (:up
                (incf y)
                (when (<= height y)
                  (decf y)
                  (setf state :right)))
               (:right
                (incf x)
                (when (<= width x)
                  (decf x)
                  (setf state :down)))
               (:down
                (decf y)
                (when (< y 0)
                  (incf y)
                  (setf state :left)))
               (:left
                (decf x)
                (when (< x 0)
                  (incf x)
                  (error "There is no edge.")))))
    (values x y)))

(defun filter-edge (solids width height x y)
  (labels ((pos (x y)
             (* (+ x (* y width)) 2))
           (tile (x y)
             (let ((pos (pos x y)))
               (cond ((or (= -1 x) (= -1 y) (= width x) (= height y)) 1)
                     ((<= 0 pos (1- (length solids))) (aref solids pos))
                     (T 0))))
           (i (ox oy)
             (= 255 (tile (+ x ox) (+ y oy))))
           (e (ox oy)
             (< 0 (tile (+ x ox) (+ y oy)) 255)))
    (cond ((and (i +1 -1) (e +0 -1) (e +1 +0)) :tl>)
          ((and (i -1 -1) (e +0 -1) (e -1 +0)) :tr>)
          ((and (i -1 +1) (e +0 +1) (e -1 +0)) :br>)
          ((and (i +1 +1) (e +0 +1) (e +1 +0)) :bl>)
          ((and (i -1 +1) (e +0 -1) (e +1 +0)) :tl<)
          ((and (i +1 +1) (e +0 -1) (e -1 +0)) :tr<)
          ((and (i +1 -1) (e +0 +1) (e -1 +0)) :br<)
          ((and (i -1 -1) (e +0 +1) (e +1 +0)) :bl<)
          ((and (i +0 -1)) :t)
          ((and (i -1 +0)) :r)
          ((and (i +0 +1)) :b)
          ((and (i +1 +0)) :l)
          (T (error "Unknown tile configuration at ~d,~d." x y)))))

(defun fill-edge (solids tiles width height ox oy)
  (labels ((pos (x y)
             (* (+ x (* y width)) 2))
           ((setf tile) (f x y)
             (when (and (<= 0 x (1- width))
                        (<= 0 y (1- height)))
               (let ((f (alexandria:random-elt f))
                     (pos (pos x y)))
                 (setf (aref tiles (+ 0 pos)) (first f)
                       (aref tiles (+ 1 pos)) (second f))))))
    (loop with x = ox with y = oy
          for edge = (filter-edge solids width height x y)
          do (setf (tile x y) (cdr (assoc edge *tile-map*)))
             (ecase edge
               (:l (incf y))
               (:r (decf y))
               (:t (incf x))
               (:b (decf x))
               (:tl> (incf x))
               (:tr> (decf y))
               (:br> (decf x))
               (:bl> (incf y))
               (:tl< (decf y))
               (:tr< (decf x))
               (:br< (incf y))
               (:bl< (incf x)))
             (when (and (= x ox) (= y oy))
               (loop-finish))
          collect (vec x y))))

(defun fill-innards (solids tiles edge width height x- x+ y- y+)
  (labels ((pos (x y)
             (* (+ x (* y width)) 2))
           (tile (x y)
             (aref solids (+ 0 (pos x y))))
           ((setf tile) (f x y)
             (let ((f (alexandria:random-elt f)))
               (setf (aref tiles (+ 0 (pos x y))) (first f)
                     (aref tiles (+ 1 (pos x y))) (second f)))))
    (loop for y from (max 0 y-) to (min y+ height)
          do (loop for x from (max 0 x-) to (min x+ width)
                   do (when (= 255 (tile x y))
                        (setf (tile x y)
                              (cdr (or (assoc (round (mindist (vec x y) edge)) *tile-map*)
                                       (assoc T *tile-map*)))))))))

(defun %auto-tile (solids tiles width height x y)
  (let ((solids (copy-seq solids)))
    (%flood-fill solids width height x y (vec2 255 0))
    (multiple-value-bind (x y) (find-edge solids width height x y)
      (let* ((edge (fill-edge solids tiles width height x y))
             (x- (truncate (loop for pos in edge minimize (vx pos))))
             (x+ (truncate (loop for pos in edge maximize (vx pos))))
             (y- (truncate (loop for pos in edge minimize (vy pos))))
             (y+ (truncate (loop for pos in edge maximize (vy pos)))))
        (fill-innards solids tiles edge width height x- x+ y- y+)))))

(defparameter *tile-map*
  '((:t (1 15))
    (:r (2 14))
    (:b (1 13))
    (:l (0 14))
    (:tl> (0 15))
    (:tr> (2 15))
    (:br> (2 13))
    (:bl> (0 13))
    (:tl< (6 13))
    (:tr< (5 13))
    (:br< (5 14))
    (:bl< (6 14))
    (1 (3 10) (3 11) (3 12) (4 10) (4 11) (4 12))
    (2 (4 10) (4 11) (4 12) (5 10) (5 11) (5 12))
    (3 (5 10) (5 11) (5 12) (6 10) (6 11) (6 12))
    (4 (6 10) (6 11) (6 12))
    (T (6 12))))
