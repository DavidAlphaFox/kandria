(in-package #:org.shirakumo.fraf.leaf)

(defun %flood-fill (layer width height x y fill)
  (let* ((tmp (vec2 0 0)))
    (labels ((pos (x y)
               (* (+ x (* y width)) 2))
             (tile (x y)
               (vsetf tmp
                      (aref layer (+ 0 (pos x y)))
                      (aref layer (+ 1 (pos x y)))))
             ((setf tile) (f x y)
               (setf (aref layer (+ 0 (pos x y))) (truncate (vx f))
                     (aref layer (+ 1 (pos x y))) (truncate (vy f)))))
      (let ((q ()) (find (vec2 (aref layer (+ 0 (pos x y)))
                               (aref layer (+ 1 (pos x y))))))
        (unless (v= fill find)
          (push (cons x y) q)
          (loop while q for (n . y) = (pop q)
                for w = n for e = n
                do (loop until (or (= w 0) (v/= (tile (1- w) y) find))
                         do (decf w))
                   (loop until (or (= e (1- width)) (v/= (tile (1+ e) y) find))
                         do (incf e))
                   (loop for i from w to e
                         do (setf (tile i y) fill)
                            (when (and (< y (1- height)) (v= (tile i (1+ y)) find))
                              (pushnew (cons i (1+ y)) q))
                            (when (and (< 0 y) (v= (tile i (1- y)) find))
                              (pushnew (cons i (1- y)) q)))))))))

(defun find-edge (solids width height x y)
  (labels ((pos (x y)
             (* (+ x (* y width)) 2)))
    (loop with state = :up
          while (= 255 (aref solids (+ 0 (pos x y))))
          do (ecase state
               (:up
                (incf y)
                (when (<= height y)
                  (decf y)
                  (setf state :right)))
               (:right
                (incf x)
                (when (<= width x)
                  (decf x)
                  (setf state :down)))
               (:down
                (decf y)
                (when (< y 0)
                  (incf y)
                  (setf state :left)))
               (:left
                (decf x)
                (when (< x 0)
                  (incf x)
                  (error "There is no edge.")))))
    (values x y)))

(defun filter-edge (solids width height x y)
  (labels ((pos (x y)
             (* (+ x (* y width)) 2))
           (tile (x y)
             (aref solids (+ 0 (pos x y)))))
    (let ((u (tile x (1+ y)))
          (r (tile (1+ x) y))
          (b (tile x (1- y)))
          (l (tile (1- x) y)))
      ;; FIXME: improved corner detection
      (cond ((and (< 0 b 255) (< 0 u 255))
             (if (= 255 l) :r :l))
            ((and (< 0 l 255) (< 0 r 255))
             (if (= 255 b) :t :b))
            ((and (< 0 b 255) (< 0 r 255))
             (if (= 255 l) :tl< :tl>))
            ((and (< 0 l 255) (< 0 b 255))
             (if (= 255 r) :tr< :tr>))
            ((and (< 0 u 255) (< 0 l 255))
             (if (= 255 r) :br< :br>))
            ((and (< 0 r 255) (< 0 u 255))
             (if (= 255 l) :bl< :bl>))
            (T
             (error "Unknown tile configuration at ~d,~d." x y))))))

(defun fill-edge (solids tiles width height ox oy)
  (labels ((pos (x y)
             (* (+ x (* y width)) 2))
           ((setf tile) (f x y)
             (setf (aref tiles (+ 0 (pos x y))) (first f)
                   (aref tiles (+ 1 (pos x y))) (second f))))
    (loop with x = ox with y = oy
          for edge = (filter-edge solids width height x y)
          do (setf (tile x y) (getf *edge-map* edge))
             (ecase edge
               (:l (incf y))
               (:r (decf y))
               (:t (incf x))
               (:b (decf x))
               (:tl> (incf x))
               (:tr> (decf y))
               (:br> (decf x))
               (:bl> (incf y))
               (:tl< (decf y))
               (:tr< (decf x))
               (:br< (incf y))
               (:bl< (incf x)))
             (when (or (< x 0) (<= width x)
                       (< y 0) (<= height y))
               (setf (values x y) (find-edge solids width height x y)))
          until (and (= x ox) (= y oy)))))

(defun filter-innard (solids width height x y prev)
  (labels ((pos (x y)
             (* (+ x (* y width)) 2))
           (tile (x y)
             (aref solids (+ 0 (pos x y)))))
    (ecase prev
      (:up
       (if (< 0 (tile (1- x) y) 255)
           (if (< 0 (tile x (1+ y)) 255)
               :right
               :up)
           :left))
      (:right
       (if (< 0 (tile x (1+ y)) 255)
           (if (< 0 (tile (1+ x) y) 255)
               :down
               :right)
           :up))
      (:down
       (if (< 0 (tile (1+ x) y) 255)
           (if (< 0 (tile x (1- y)) 255)
               :left
               :down)
           :right))
      (:left
       (if (< 0 (tile x (1- y)) 255)
           (if (< 0 (tile (1- x) y) 255)
               :up
               :left)
           :down)))))

(defun fill-innards (solids tiles width height ox oy)
  (labels ((pos (x y)
             (* (+ x (* y width)) 2))
           ((setf tile) (f x y)
             (setf (aref tiles (+ 0 (pos x y))) (first f)
                   (aref tiles (+ 1 (pos x y))) (second f))))
    (let ((init (ecase (filter-edge solids width height ox oy)
                  ((:l :tr<) (incf ox) :up)
                  ((:r :br<) (decf ox) :down)
                  ((:t :bl<) (decf oy) :right)
                  ((:b :tl<) (incf oy) :left)
                  (:tl> (incf ox) (decf oy) :right)
                  (:tr> (decf ox) (decf oy) :down)
                  (:br> (decf ox) (incf oy) :left)
                  (:bl> (incf ox) (incf oy) :up))))
      (loop with x = ox with y = oy
            for step = init then (filter-innard solids width height x y step)
            do (setf (tile x y) '(1 14))
               (ecase step
                 (:up (incf y))
                 (:right (incf x))
                 (:down (decf y))
                 (:left (decf x)))
            until (and (= x ox) (= y oy))))))

(defun %auto-tile (solids tiles width height x y)
  (let ((solids (copy-seq solids)))
    (%flood-fill solids width height x y (vec2 255 0))
    (multiple-value-bind (x y) (find-edge solids width height x y)
      (fill-edge solids tiles width height x y)
      (fill-innards solids tiles width height x y))))

(defparameter *edge-map*
  '(:t (1 15)
    :r (2 14)
    :b (1 13)
    :l (0 14)
    :tl> (0 15)
    :tr> (2 15)
    :br> (2 13)
    :bl> (0 13)
    :tl< (6 13)
    :tr< (5 13)
    :br< (5 14)
    :bl< (6 14)))
