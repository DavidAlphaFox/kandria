(in-package #:org.shirakumo.fraf.leaf)

(defstruct (block (:constructor make-block (s)))
  (s 0 :type (unsigned-byte 16)))

(defstruct (ground (:include block)
                   (:constructor make-ground (s))))

(defstruct (platform (:include block)
                     (:constructor make-platform (s))))

(defstruct (spike (:include block)
                  (:constructor make-spike (s))))

(defstruct (slope (:include block)
                  (:constructor make-slope (s l r)))
  (l NIL :type vec2)
  (r NIL :type vec2))

(defstruct (stopper (:include block)
                    (:constructor make-stopper (s))))

(defun make-surface-blocks (t-s slope-steps)
  (let ((blocks (make-array (+ 5 (* 2 (reduce #'+ slope-steps)))))
        (i -1))
    (flet ((make (c &rest args)
             (setf (aref blocks (incf i)) (apply (find-symbol (format NIL "MAKE-~a" c)) t-s args))))
      (make 'block)
      (make 'ground)
      (make 'platform)
      (make 'spike)
      (loop for steps in slope-steps
            do (loop for i from 0 below steps
                     for l = (* (/ i steps) t-s)
                     for r = (* (/ (1+ i) steps) t-s)
                     do (make 'slope
                              (vec2 (/ t-s -2) (- (floor l) (/ t-s 2)))
                              (vec2 (/ t-s +2) (- (floor r) (/ t-s 2)))))
            do (loop for i downfrom steps above 0
                     for l = (* (/ i steps) t-s)
                     for r = (* (/ (1- i) steps) t-s)
                     do (make 'slope
                              (vec2 (/ t-s -2) (- (floor l) (/ t-s 2)))
                              (vec2 (/ t-s +2) (- (floor r) (/ t-s 2))))))
      (make 'stopper)
      blocks)))

(sb-ext:defglobal +surface-blocks+ NIL)
(setf +surface-blocks+ (make-surface-blocks +tile-size+ '(1 2 3)))

(defmethod velocity ((block block))
  #.(vec2 0 0))

(defun aabb (seg-pos seg-vel aabb-pos aabb-size)
  (declare (type vec2 seg-pos seg-vel aabb-pos aabb-size))
  (declare (optimize speed))
  (sb-int:with-float-traps-masked (:overflow :underflow :inexact :invalid)
    (let* ((scale (vec2 (if (= 0 (vx seg-vel)) float-features:single-float-positive-infinity (/ (vx seg-vel)))
                        (if (= 0 (vy seg-vel)) float-features:single-float-positive-infinity (/ (vy seg-vel)))))
           (sign (vec2 (if (<= 0. (vx seg-vel)) +1. -1.)
                       (if (<= 0. (vy seg-vel)) +1. -1.)))
           (near (v* (v- (v- aabb-pos (v* sign aabb-size)) seg-pos) scale))
           (far  (v* (v- (v+ aabb-pos (v* sign aabb-size)) seg-pos) scale)))
      (unless (or (< (vy far) (vx near))
                  (< (vx far) (vy near)))
        (let ((t-near (max (vx near) (vy near)))
              (t-far (min (vx far) (vy far))))
          (when (and (< t-near 1)
                     (< 0 t-far))
            (let ((normal (cond ((< t-near 0)
                                 (let ((dist (v- seg-pos aabb-pos)))
                                   (if (< (abs (vy dist)) (abs (vx dist)))
                                       (vec (signum (vx dist)) 0)
                                       (vec 0 (signum (vy dist))))))
                                ((< (vy near) (vx near))
                                 (vec (- (vx sign)) 0))
                                (T
                                 (vec 0 (- (vy sign)))))))
              (unless (= 0 (v. normal seg-vel))
                ;; KLUDGE: This test is necessary in order to ignore vertical edges
                ;;         that seem to stick out of the blocks. I have no idea why.
                (unless (and (/= 0 (vy normal))
                             (<= (vx aabb-size) (abs (- (vx aabb-pos) (vx seg-pos)))))
                  (make-hit NIL
                            aabb-pos
                            t-near
                            normal))))))))))

(defun slope (pos vel size slope loc)
  (declare (type vec2 pos vel size loc))
  (declare (optimize speed))
  (let* ((la (v+ loc (slope-l slope)))
         (lb (v+ loc (slope-r slope)))
         (dir (v- lb la))
         (ln (nvunit (vec (- (vy dir)) (vx dir))))
         (min (vmin la lb))
         (max (vmax la lb))
         (r (+ (* (vx size) (abs (vx ln)))
               (* (vy size) (abs (vy ln)))))
         (b (v. (v- la pos) ln))
         (v (v. vel ln)))
    (when (< v 0) (setf r (- r)))
    (when (= v 0) (return-from slope))
    (let ((hit (max 0f0 (/ (- b r) v)))
          (out (min 1f0 (/ (+ b r) v))))
      (cond ((< (vx vel) 0)
             (when (< (+ (vx pos) (vx size)) (vx min)) (return-from slope))
             (setf hit (max hit (/ (- (vx max) (- (vx pos) (vx size))) (vx vel))))
             (setf out (min out (/ (- (vx min) (+ (vx pos) (vx size))) (vx vel)))))
            ((< 0 (vx vel))
             (when (< (vx max) (- (vx pos) (vx size))) (return-from slope))
             (setf hit (max hit (/ (- (vx min) (+ (vx pos) (vx size))) (vx vel))))
             (setf out (min out (/ (- (vx max) (- (vx pos) (vx size))) (vx vel)))))
            ((or (< (+ (vx pos) (vx size)) (vx min))
                 (< (vx max) (- (vx pos) (vx size))))
             (return-from slope)))
      (when (< out hit) (return-from slope))
      (cond ((< (vy vel) 0)
             (when (< (+ (vy pos) (vy size)) (vy min)) (return-from slope))
             (setf hit (max hit (/ (- (vy max) (- (vy pos) (vy size))) (vy vel))))
             (setf out (min out (/ (- (vy min) (+ (vy pos) (vy size))) (vy vel)))))
            ((< 0 (vy vel))
             (when (< (vy max) (- (vy pos) (vy size))) (return-from slope))
             (setf hit (max hit (/ (- (vy min) (+ (vy pos) (vy size))) (vy vel))))
             (setf out (min out (/ (- (vy max) (- (vy pos) (vy size))) (vy vel)))))
            ((or (< (- (vy pos) (vy size)) (vy min))
                 (< (+ (vy pos) (vy size)) (vy max)))
             (return-from slope)))
      (when (< out hit) (return-from slope))
      hit)))
